<chapter id="RESTEasy_Client_Framework">
   <title>RESTEasy Client Framework</title>

   <para>

      The Resteasy Client Framework is the mirror opposite of the JAX-RS server-side specification. Instead of using
      JAX-RS annotations to map an incoming request to your RESTFul Web Service method, the client framework builds an
      HTTP request that it uses to invoke on a remote RESTful Web Service. This remote service does not have to be a
      JAX-RS service and can be any web resource that accepts HTTP requests.
   </para>
   <para>

      Resteasy has a client proxy framework that allows you to use JAX-RS annotations to invoke on a remote HTTP
      resource.
      The way it works is that you write a Java interface and use JAX-RS annotations on methods and the interface. For
      example:
   </para>
   <para>

      <programlisting>
         public interface SimpleClient
         {
         @GET
         @Path("basic")
         @Produces("text/plain")
         String getBasic();

         @PUT
         @Path("basic")
         @Consumes("text/plain")
         void putBasic(String body);

         @GET
         @Path("queryParam")
         @Produces("text/plain")
         String getQueryParam(@QueryParam("param")String param);

         @GET
         @Path("matrixParam")
         @Produces("text/plain")
         String getMatrixParam(@MatrixParam("param")String param);

         @GET
         @Path("uriParam/{param}")
         @Produces("text/plain")
         int getUriParam(@PathParam("param")int param);
         }
      </programlisting>
   </para>
   <para>

      Resteasy has a simple API based on Apache HttpClient. You generate a proxy then you can invoke methods on the
      proxy. The invoked method gets translated to an HTTP request based on how you annotated the method and posted to
      the server. Here's how you would set this up:
   </para>
   <para>

      <programlisting>
         import org.resteasy.plugins.client.httpclient.ProxyFactory;
         ...
         // this initialization only needs to be done once per VM
         ResteasyProviderFactory.initializeInstance();
         RegisterBuiltin.register(ResteasyProviderFactory.getInstance());


         SimpleClient client = ProxyFactory.create(SimpleClient.class, "http://localhost:8081");
         client.putBasic("hello world");
      </programlisting>
   </para>
   <para>

      Please see the ProxyFactory javadoc for more options. For instance, you may want to fine tune the HttpClient
      configuration.
   </para>
   <para>


   </para>
   <para>

      @CookieParam works the mirror opposite of its server-side counterpart and creates a cookie header to send to the
      server. You do not need to use @CookieParam if you allocate your own javax.ws.rs.core.Cookie object and pass it as
      a parameter to a client proxy method. The client framework understands that you are passing a cookie to the server
      so no extra metadata is needed.
   </para>
   <para>


   </para>
   <para>

      The client framework can use the same providers available on the server. You must manually register them through
      the ResteasyProviderSingleton using the addMessageBodyReader() and addMessageBodyWriter() methods.
   </para>
   <para>


   </para>
   <sect1 id="Custom_client-side_responses">
      <title>Custom client-side responses</title>

      <para>

         Sometimes you are interested not only in the response body of a client request, but also either the response
         code and/or response headers. The Client-Proxy framework has two ways to get at this information
      </para>
      <para>


      </para>
      <para>

         You may return a javax.ws.rs.core.Response.Status enumeration from your method calls:
      </para>
      <para>

         <programlisting>

            @Path("/")
            public interface MyProxy {

            @POST
            Response.Status updateSite(MyPojo pojo);
            }
         </programlisting>
      </para>
      <para>

         Interally, after invoking on the server, the client proxy internals will convert the HTTP response code into a
         Response.Status enum.
      </para>
      <para>


      </para>
      <para>

         If you are interested in everything, you can get it with the org.resteasy.spi.ClientResponse interface:
      </para>
      <para>

         <programlisting>

            /**
            * Response interface for the RESTEasy client framework. Use this in your client proxy interface method
            return type
            * declarations if you want access to the response entity as well as status and header information.
            *
            * @author &lt;a href="mailto:bill@burkecentral.com"&gt;Bill Burke&lt;/a&gt;
            * @version $Revision: 1 $
            */
            public interface ClientResponse&lt;T&gt;
            {
            T getEntity();

            MultivaluedMap&lt;String, String&gt; getHeaders();

            int getStatus();
            }


         </programlisting>
      </para>
      <para>

         You must use it as a generic with the entity body type you are interested in receiving back from the response
         unmarshalling layer. Here's an example
      </para>
      <para>

         <programlisting>
            @Path("/")
            public interface LibraryService {

            @GET
            @Produces("application/xml")
            ClientResponse&lt;LibraryPojo&gt; getAllBooks();
            }
         </programlisting>
      </para>
      <para>

         We need to include the LibraryPojo in ClientResponse's generic declaration so that the client proxy framework
         knows how to unmarshal the HTTP response body. We could not reuse the javax.ws.rs.core.Response class because
         it is not a Java generic and we would have had no way to get this type information.
      </para>
      <para>


      </para>
   </sect1>
   <sect1 id="Client_error_handling">
      <title>Client error handling</title>

      <para>

         If you are using the Client Framework and your proxy methods return something other than an un-type
         ClientResponse, then the default client error handling comes into play. Any response code that is greater tha
         399 will automatically cause a org.jboss.resteasy.client.ClientResponseFailure exception
      </para>
      <para>

         <programlisting>
            @GET
            ClientResponse&lt;String&gt; get() // will throw a ClientResponseFailure on response &gt; code 399

            @POST
            ClientResponse post(); // will not throw a ClientResponseFailure

            @GET
            MyObject get(); // will throw a ClientResponseFailure on response code &gt; 399
         </programlisting>
      </para>
      <para>


      </para>
   </sect1>
</chapter>
