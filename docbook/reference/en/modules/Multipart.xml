<sect1 id="Multipart">
   <title>Multipart Providers</title>
   <para>Resteasy has rich support for the "multipart/*" and "multipart/form-data" mime types.  The multipart mime
      format is used to pass lists of content bodies.  Multiple content bodies are embedded in one message.
      "multipart/form-data" is often found in web application HTML Form documents and is generally used to
      upload files.  The form-data format is the same as other multipart formats, except that each inlined piece
      of content has a name associated with it.
    </para>
   <para>RESTEasy provides
   a custom API for reading and writing multipart types as well as marshalling arbitrary List (for any multipart type)
      and Map (multipart/form-data only)
   objects</para>
   <sect2 id="MultipartInput">
      <title>Input with multipart/mixed</title>
      <para>When writing a JAX-RS service, RESTEasy provides an interface that allows you to read in any
      multipart mime type.  org.jboss.resteasy.plugins.providers.multipart.MultipartInput</para>
      <programlisting>
package org.jboss.resteasy.plugins.providers.multipart;

public interface MultipartInput
{
   List&lt;InputPart&gt; getParts();

   String getPreamble();
}

public interface InputPart
{
   MultivaluedMap&lt;String, String&gt; getHeaders();

   String getBodyAsString();

   &lt;T&gt; T getBody(Class&lt;T&gt; type, Type genericType) throws IOException;

   &lt;T&gt; T getBody(org.jboss.resteasy.util.GenericType&lt;T&gt; type) throws IOException;

   MediaType getMediaType();
}
      </programlisting>
      <para>MultipartInput is a simple interface that allows you to get access to each part of the multipart message.
      Each part is represented by an InputPart interface. Each part has a set of headers associated with it
      You can unmarshall the part by calling one of the getBody() methods.  The Type genericType parameter can be null,
      but the Class type parameter must be set.  Resteasy will find a MessageBodyReader based on the media type
      of the part as well as the type information you pass in.  The following piece of code is unmarshalling
      parts which are XML into a JAXB annotated class called Customer.
      </para>
<programlisting>
   @Path("/multipart")
   public class MyService
   {
      @PUT
      @Consumes("multipart/mixed")
      public void put(MultipartInput input)
      {
         List&lt;Customer&gt; customers = new ArrayList...;
         for (InputPart part : input.getParts())
         {
            Customer cust = part.getBody(Customer.class, null);
            customers.add(cust);
         }
      }
   }
</programlisting>
      <para>
         Sometimes you may want to unmarshall a body part that is sensitive to generic type metadata.  In this case
         you can use the org.jboss.resteasy.util.GenericType class.  Here's an example of unmarshalling a type that
         is sensitive to generic type metadata.
      </para>
<programlisting>
   @Path("/multipart")
   public class MyService
   {
      @PUT
      @Consumes("multipart/mixed")
      public void put(MultipartInput input)
      {
         for (InputPart part : input.getParts())
         {
            List&lt;Customer&gt; cust = part.getBody(new GenericType&gt;List&gt;Customer&lt;&lt;() {});
         }
      }
   }

</programlisting>
      <para>
         Use of GenericType is required because it is really the only way to obtain generic type information at runtime.
      </para>
   </sect2>
   <sect2 id="multipart_list">
      <title>java.util.List with multipart data</title>
      <para>If your body parts are uniform, you do not have to manually unmarshall each and every part.
      You can just provide a java.util.List as your input parameter.  It must have the type it is
      unmarshalling with the generic parameter of the List type declaration.  Here's an example again
      of unmarshalling a list of customers.</para>
<programlisting>
   @Path("/multipart")
   public class MyService
   {
      @PUT
      @Consumes("multipart/mixed")
      public void put(List&lt;Customer&gt; customers)
      {
         ...
      }
   }

</programlisting>
   </sect2>
   <sect2 id="MultipartFormData">
      <title>Input with multipart/form-data</title>
      <para>When writing a JAX-RS service, RESTEasy provides an interface that allows you to read in
      multipart/form-data mime type.  "multipart/form-data" is often found in web application HTML Form documents and is generally used to
      upload files.  The form-data format is the same as other multipart formats, except that each inlined piece
      of content has a name associated with it.  The interface used for form-data input is
         org.jboss.resteasy.plugins.providers.multipart.MultipartFormDataInput</para>
<programlisting>
public interface MultipartFormDataInput extends MultipartInput
{
   Map&lt;String, InputPart&gt; getFormData();

   &lt;T&gt; T getFormDataPart(String key, Class&lt;T&gt; rawType, Type genericType) throws IOException;

   &lt;T&gt; T getFormDataPart(String key, GenericType&lt;T&gt; type) throws IOException;
}
</programlisting>
      <para>
         It works in much the same way as MultipartInput described earlier in this chapter.
      </para>

   </sect2>
   <sect2 id="multipart_map">
      <title>java.util.Map with multipart/form-data</title>
      <para>With form-data, if your body parts are uniform, you do not have to manually unmarshall each and every part.
      You can just provide a java.util.Map as your input parameter.  It must have the type it is
      unmarshalling with the generic parameter of the List type declaration.  Here's an example of
      of unmarshalling a Map of Customer objects which are JAXB annotated classes.</para>
<programlisting>
   @Path("/multipart")
   public class MyService
   {
      @PUT
      @Consumes("multipart/form-data")
      public void put(Map&lt;String, Customer&gt; customers)
      {
         ...
      }
   }

</programlisting>
   </sect2>
   <sect2 id="multipart_output">
      <title>Output with multipart</title>
      <para>RESTEasy provides a simple API to output multipart data.</para>
<programlisting><![CDATA[
package org.jboss.resteasy.plugins.providers.multipart;

public class MultipartOutput
{
   public OutputPart addPart(Object entity, MediaType mediaType)

   public OutputPart addPart(Object entity, GenericType type, MediaType mediaType)

   public OutputPart addPart(Object entity, Class type, Type genericType, MediaType mediaType)

   public List<OutputPart> getParts()

   public String getBoundary()

   public void setBoundary(String boundary)
}

public class OutputPart
{
   public MultivaluedMap<String, Object> getHeaders()

   public Object getEntity()

   public Class getType()

   public Type getGenericType()

   public MediaType getMediaType()
}

]]>
</programlisting>
      <para>When you want to output multipart data it is as simple as creating a MultipartOutput object
      and calling addPart() methods.  Resteasy will automatically find a MessageBodyWriter
      to marshall your entity objects.  Like MultipartInput, sometimes you may have marshalling
      which is sensitive to generic type metadata.  In that case, use GenericType.  Most of the time though
      passing in an Object and its MediaType is enough.  In the example below, we are sending
      back a "multipart/mixed" format back to the calling client.  The parts are
      Customer objects which are JAXB annotated and will be marshalling into "application/xml".</para>
<programlisting>
   @Path("/multipart")
   public class MyService
   {
      @GET
      @Produces("multipart/mixed")
      public MultipartOutput get()
      {
         MultipartOutput output = new MultipartOutput();
         output.addPart(new Customer("bill"), MediaType.APPLICATION_XML_TYPE);
         output.addPart(new Customer("monica"), MediaType.APPLICATION_XML_TYPE);
         return output;
      }

</programlisting>
   </sect2>
   <sect2 id="multipart_list_output">
      <title>Multipart Output with java.util.List</title>
      <para>If your body parts are uniform, you do not have to manually marshall each and every part or even
         use a MultipartOutput object..
      You can just provide a java.util.List.  It must have the generic type it is
      marshalling with the generic parameter of the List type declaration.  You must also annotate the method
         with the @PartType annotation to specify what media type each part is.  Here's an example
      of sending back a list of customers back to a client.  The customers are JAXB objects</para>
<programlisting>
   @Path("/multipart")
   public class MyService
   {
      @GET
      @Produces("multipart/mixed")
      @PartType("application/xml")
      public List&lt;Customer&gt; get()
      {
         ...
      }
   }

</programlisting>
   </sect2>
   <sect2 id="multipart_formdata_output">
      <title>Output with multipart/form-data</title>
      <para>RESTEasy provides a simple API to output multipart/form-data.</para>
<programlisting><![CDATA[
package org.jboss.resteasy.plugins.providers.multipart;

public class MultipartFormDataOutput extends MultipartOutput
{
   public OutputPart addFormData(String key, Object entity, MediaType mediaType)

   public OutputPart addFormData(String key, Object entity, GenericType type, MediaType mediaType)

   public OutputPart addFormData(String key, Object entity, Class type, Type genericType, MediaType mediaType)

   public Map<String, OutputPart> getFormData()
}
]]>
</programlisting>
      <para>When you want to output multipart/form-data it is as simple as creating a MultipartFormDataOutput object
      and calling addFormData() methods.  Resteasy will automatically find a MessageBodyWriter
      to marshall your entity objects.  Like MultipartInput, sometimes you may have marshalling
      which is sensitive to generic type metadata.  In that case, use GenericType.  Most of the time though
      passing in an Object and its MediaType is enough.  In the example below, we are sending
      back a "multipart/form-data" format back to the calling client.  The parts are
      Customer objects which are JAXB annotated and will be marshalling into "application/xml".</para>
<programlisting>
   @Path("/form")
   public class MyService
   {
      @GET
      @Produces("multipart/form-data")
      public MultipartFormDataOutput get()
      {
         MultipartFormDataOutput output = new MultipartFormDataOutput();
         output.addPart("bill", new Customer("bill"), MediaType.APPLICATION_XML_TYPE);
         output.addPart("monica", new Customer("monica"), MediaType.APPLICATION_XML_TYPE);
         return output;
      }

</programlisting>
   </sect2>
   <sect2 id="multipart_map_output">
      <title>Multipart FormData Output with java.util.Map</title>
      <para>If your body parts are uniform, you do not have to manually marshall each and every part or even
         use a MultipartFormDataOutput object..
      You can just provide a java.util.Map.  It must have the generic type it is
      marshalling with the generic parameter of the Map type declaration.  You must also annotate the method
         with the @PartType annotation to specify what media type each part is.  Here's an example
      of sending back a list of customers back to a client.  The customers are JAXB objects</para>
<programlisting>
   @Path("/multipart")
   public class MyService
   {
      @GET
      @Produces("multipart/form-data")
      @PartType("application/xml")
      public Map&lt;String, Customer&gt; get()
      {
         ...
      }
   }

</programlisting>
   </sect2>
   <sect2 id="multipartform_annotation">
      <title>@MultipartForm and POJOs</title>
      <para>If you have a exact knowledge of your multipart/form-data packets, you can map
      them to and from a POJO class to and from multipart/form-data using the
      @org.jboss.resteasy.annotations.providers.multipart.MultipartForm annotation
      and the JAX-RS @FormParam annotation.  You simple define a POJO with
      at least a default constructor and annotate its fields and/or properties
      with @FormParams.  These @FormParams must also be annotated with
      @org.jboss.resteasy.annotations.providers.multipart.PartType if you
      are doing output.  For example:</para>
<programlisting>
   public class CustomerProblemForm {
      @FormData("customer")
      @PartType("application/xml")
      private Customer customer;

      @FormData("problem")
      @PartType("text/plain")
      private String problem;

      public Customer getCustomer() { return customer; }
      public void setCustomer(Customer cust) { this.customer = cust; }
      public String getProblem() { return problem; }
      public void setProblem(String problem) { this.problem = problem; }
   }
</programlisting>
      <para>After defining your POJO class you can then use it to represent multipart/form-data.  Here's
      an example of sending a CustomerProblemForm using the RESTEasy client framework</para>
<programlisting>
   @Path("portal")
   public interface CustomerPortal {

      @Path("issues/{id}")
      @Consumes("multipart/form-data")
      @PUT
      public void putProblem(@MultipartForm CustomerProblemForm,
                             @PathParam("id") int id);
   }

   {
       CustomerPortal portal = ProxyFactory.create(CustomerPortal.class, "http://example.com");
       CustomerProblemForm form = new CustomerProblemForm();
       form.setCustomer(...);
       form.setProblem(...);

       portal.putProblem(form, 333);
   }
</programlisting>
      <para>You see that the @MultipartForm annotation was used to tell RESTEasy that the object has @FormParam
      and that it should be marshalled from that.  You can also use the same object to receive multipart data.
      Here is an example of the server side counterpart of our customer portal.</para>
<programlisting>
   @Path("portal")
   public class CustomerPortalServer {

      @Path("issues/{id})
      @Consumes("multipart/form-data")
      @PUT
      public void putIssue(@MultipartForm CustoemrProblemForm,
                           @PathParm("id") int id) {
         ... write to database...
      }
   }
</programlisting>
   </sect2>
</sect1>